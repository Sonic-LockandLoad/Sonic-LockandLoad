class LockLoadPlayer : PlayerPawn 
{
	int DoubleJumpCounter;
	double OldZ;
	bool ReticleActive;
	int JumpAngle;
	Default
	{
		Health 100;
		Speed 4;
		Player.ForwardMove 1, 0.5;
		Player.SideMove 1, 0.5;
		Radius 15;
		Height 42;
		Player.ViewHeight 42.0;
		Player.AttackZOffset 16.5;
		PainChance 250;
		Mass 100;
		Player.MaxHealth 999;
		Player.JumpZ 15.0;
	}
	override int TakeSpecialDamage(Actor inflictor, Actor source, int damage, Name damagetype)
	{
		Super.TakeSpecialDamage(inflictor, source, damage, damagetype);
		if (damage > 0 && damage < 999 && !(player.cheats & CF_GODMODE) && !CountInv("PowerInvulnerable")) {
			if (health >= 20 && damage > health) {
				damage = health - 1;
			}
			A_StartSound("sglobal/loserings", 6);
			int ringcount = damage;
			int maxrange  = damage / 4;
			if (maxrange < 5) maxrange = 5;
			if (maxrange > 15) maxrange = 15;
			if (ringcount > 150) ringcount = 150;
			for (int x = 1; x <= ringcount; x++) {
				int x = random(maxrange * -1, maxrange);
				int y = random(maxrange * -1, maxrange);
				int xoffset;
				if (damagetype == "Falling") {
					xoffset = x * cos(angle) - 75;
				}
				A_SpawnItemEx("DroppedRingPlayer", xoffset, 0, 1, x, y, 15);
			}
		}
		bool IsParrying = CountInv("PowerSwordParry") || CountInv("PowerBlocking");
		if (GetCvar("OneHitMode") && !IsParrying && DamageFactor > 0) {
			return 9999;
		}
		return damage;
	}
	override void FallAndSink(double grav, double oldfloorz)
	{
		if (waterlevel >= 2 && pos.z > oldfloorz && Vel.Z <= 5) Vel.Z -= Gravity;
		Super.FallAndSink(grav, oldfloorz);
	}
	States
	{
		Spawn:
			PLAY A -1;
			Loop;
		See:
			PLAY ABCD 4;
			Loop;
		Missile:
			PLAY E 12;
			Goto Spawn;
		Melee:
			PLAY F 6 BRIGHT;
			Goto Missile;
		Pain:
			PLAY G 4;
			PLAY G 0; 
			PLAY G 4;
			Goto Spawn;
		Death.Drowned:
			TNT1 A 0 A_PlaySound("sglobal/drown");
			Goto Death+2;
		Death:
			TNT1 A 0;
			TNT1 A 0 ACS_NamedExecute("DeathMusic", 0, 0);
			PLAY H 10;
			PLAY I 10;
			PLAY J 10 A_NoBlocking;
			PLAY KLM 10;
			PLAY N -1;
			Stop;
		XDeath:
			TNT1 A 0 ACS_NamedExecute("DeathMusic", 0, 0);
			TNT1 A 0;
			TNT1 A 0;
			PLAY O 5;
			PLAY P 5;
			PLAY Q 5 A_NoBlocking;
			PLAY RSTUV 5;
			PLAY W -1;
			Stop;
	}
	override void Tick()
	{
		CheckWallJumpReady();
		CheckEnemyProximity();
		HandleReticle();
		SetPlayerSpeed();
		Super.Tick();
	}

	void CheckWallJumpReady()
	{
		bool TouchingWall = false;
		for (int x = 0; x <= 360; x += 90) {
			TouchingWall = CheckLOF(CLOFF_JUMP_ON_MISS | CLOFF_SKIPENEMY | CLOFF_SKIPFRIEND | CLOFF_SKIPOBJECT | CLOFF_MUSTBESOLID | CLOFF_ALLOWNULL | CLOFF_NOAIM_VERT, 32, 0, x);
			if (TouchingWall) {
				JumpAngle = x;
				cvar.FindCvar("CanWallJump").SetBool(TouchingWall);
				break;
			}
		}
		if (!TouchingWall) {
			cvar.FindCvar("CanWallJump").SetBool(false);
		}
	}

	void CheckEnemyProximity()
	{
		cvar.FindCvar("CloseToEnemy").SetBool(CheckLOF(CLOFF_JUMPENEMY | CLOFF_SKIPOBJECT | CLOFF_MUSTBESHOOTABLE | CLOFF_JUMPNONHOSTILE, 128));
		OldZ = Pos.Z;
	}

	void HandleReticle()
	{
		FTranslatedLineTarget ltinfo;
		bool SonicPrerequisite = CountInv("SonicCheck");
		bool ShadowPrerequisite = CountInv("ShadowCheck") && !player.onground;
		bool AmyPrerequisite = CountInv("AmyCheck") && !player.onground && player.ReadyWeapon.GetClassName() == "PikoPikoHammer";
		bool HomingPrerequisite = SonicPrerequisite || ShadowPrerequisite || AmyPrerequisite;
		if (GetCvar("HomingReticle") && HomingPrerequisite) {
			bool ltattack = LineAttack(angle, 896, pitch, 0, 'None', "InvisiblePuff", LAF_NORANDOMPUFFZ | LAF_NOINTERACT, ltinfo, 0);
			let ltarget = ltinfo.linetarget;
			if (ltarget && Distance3D(ltarget) > 128 && health > 0) {
				if (!ReticleActive) {
					A_StartSound("sweapons/reticle", 11);
					ReticleActive = true;
				}
				ACS_NamedExecute("HomingReticle");
			}
			else {
				ReticleActive = false;
			}
			cvar.FindCvar("CanHoming").SetBool(ReticleActive);
		}
		else {
			ReticleActive = false;
			cvar.FindCvar("CanHoming").SetBool(false);
		}
	}

	void SetPlayerSpeed()
	{
		if (GetCvar("ReservedMode")) {
			if (CountInv("PowerHyper")) {
				A_SetSpeed(4);
			}
			else if (CountInv("PowerSuper")) {
				A_SetSpeed(3);
			}
			else {
				A_SetSpeed(2.5);
			}
		}
		else if (CountInv("PowerHyper")) {
			A_SetSpeed(8);
		}
		else if (CountInv("PowerSuper")) {
			A_SetSpeed(6);
		}
		else {
			A_SetSpeed(4);
		}
	}
	
	double GetCurrentVelocity()
	{
		return sqrt((Vel.X ** 2) + (Vel.Y ** 2));
	}
	
	int GetDoubleJumpCount()
	{
		if (CountInv("ClassicCheck") && !CountInv("PowerHyper")) {
			return 0; // Classic Sonic can't double jump
		}
		if (CountInv("SonicCheck") && CountInv("PowerHyper")) {
			return 2; // Two extra jumps if you're Hyper Sonic
		}
		return 1; // if all else fails, give an extra jump
	}
	
	double GetHeightFromFloor()
	{
		return Pos.Z - GetZAt();
	}
	
	override void CheckJump()
	{
		let player = self.player;
		
		double WallJumpOffset = 65;
		double WallJumpDistance = 20;
		
		bool TouchingWall = GetCvar("CanWallJump");
		int buttons = GetPlayerInput(MODINPUT_BUTTONS);
		int DoubleJumpCount = GetDoubleJumpCount();
		
		if (player.onground || GetCvar("DidHoming")) {
			/* Reset the double jump counter once you touch the ground
			   or do a Homing Attack */
			DoubleJumpCounter = 0;
			cvar.FindCvar("DidJump").SetBool(false); // Reset the DidJump CVAR as well
		}
		
		bool JustJumped = GetPlayerInput(MODINPUT_BUTTONS) & BT_JUMP && !(GetPlayerInput(MODINPUT_OLDBUTTONS) & BT_JUMP);
		
		cvar.FindCvar("CanJump").SetBool(DoubleJumpCounter < DoubleJumpCount || IsClassicNotHyper());
		
		if (JustJumped && !IsBoostingMidAir()) {
			if (bNoGravity) {
				Vel.Z = 3.;
			}
			else if (level.IsJumpingAllowed() && player.onground) {
				StandardJumpLogic();
			}
			else if (CountInv("SonicCheck") && TouchingWall && GetHeightFromFloor() > 60) {
				DoubleJumpCounter = 0; // You get a free double jump after a wall jump
				DoWallJump(WallJumpOffset, WallJumpDistance, JumpAngle);
			}
			else if (level.IsJumpingAllowed() && !IsHovering() && !(CountInv("ShadowCheck") && GetCvar("CanHoming"))) {
				if (DoDoubleJump(DoubleJumpCounter, DoubleJumpCount)) {
					DoubleJumpCounter++;
				}
			}
		}
	}
	
	void StandardJumpLogic()
	{
		cvar.FindCvar("DidJump").SetBool(true);
		double jumpvelz = JumpZ * 35 / TICRATE;
		double jumpfac = 0;

		if (jumpfac > 0) {
			jumpvelz *= jumpfac;
		}
		
		if (player.crouchoffset != 0) {
			player.crouching = 1;
		}

		double speed = GetCurrentVelocity();
		double slopebonus = (Pos.Z - OldZ) * (speed / 57);
		if (slopebonus < 0)  slopebonus = 0;
		if (slopebonus > 15) slopebonus = 15;
		Vel.Z = jumpvelz + slopebonus;
		
		bOnMobj = false;
		player.jumpTics = 0;
		if (!(player.cheats & CF_PREDICTING)) {
			A_StartSound("*jump", CHAN_BODY);
		}
	}
	
	bool DoDoubleJump(int DoubleJumpCounter, int DoubleJumpCount)
	{
		if (GetCvar("Sliding")) {
			A_ChangeVelocity(Vel.X, Vel.Y, JumpZ - 2, CVF_Replace);
			A_StartSound("*jump", CHAN_BODY);
		}
		else {
			if (DoubleJumpCounter < DoubleJumpCount || waterlevel > 1) {
				A_ChangeVelocity(Vel.X, Vel.Y, JumpZ - 2, CVF_Replace);
				A_StartSound("*doublejump", CHAN_BODY);
				return true;
			}
		}
		return false;
	}
	
	void DoWallJump(int WallJumpOffset, int WallJumpDistance, int JumpAngle)
	{
		int WallJumpHeight;
		if (Vel.Z >= 1) {
			WallJumpHeight = Vel.Z + WallJumpOffset;
		}
		else {
			WallJumpHeight = WallJumpOffset;
		}
		ACS_NamedExecute("WallJump", 0, WallJumpHeight, WallJumpDistance, JumpAngle);
	}
	
	bool IsBoostingMidAir()
	{
		int buttons = GetPlayerInput(MODINPUT_BUTTONS);
		return (CountInv("SonicCheck") && player.ReadyWeapon.GetClassName() == "Caliburn" && (CountInv("PowerSuper") || CountInv("PowerHyper")) && (buttons & BT_ALTATTACK) && !player.onground);
	}

	bool IsClassicNotHyper()
	{
		return (CountInv("ClassicCheck") && !CountInv("PowerHyper"));
	}

	bool IsHovering()
	{
		int buttons = GetPlayerInput(MODINPUT_BUTTONS);
		return (CountInv("ClassicCheck") && buttons & BT_ALTATTACK && (CountInv("PowerSuper") || CountInv("PowerHyper")) && !player.onground);
	}
	
	override bool CanCrouch()
	{
		player = self.player;
		if (!player.onground) {
			return false;
		}
		Super.CanCrouch();
		return true;
	}

	void HandleCrouch(PlayerInfo player, int buttons, bool totallyfrozen)
	{
		if (CanCrouch() && !totallyfrozen && player.cmd.buttons & BT_CROUCH) {
			cvar.FindCvar("IsCrouching").SetBool(true);
			A_SetSize(-1, 24);
			Player.ViewHeight = 24;
			if (GetCurrentVelocity() >= 1.0) A_StartSound("*crouchslide", 12, CHANF_NOSTOP);
			else if (!CountInv("ClassicCheck")) A_StopSound(12);
		}
		else {
			cvar.FindCvar("IsCrouching").SetBool(false);
			A_SetSize(-1, 42);
			Player.ViewHeight = 42;
			A_StopSound(12);
		}
	}

	override void CheckCrouch(bool totallyfrozen)
	{
		let player = self.player;
		int buttons = player.cmd.buttons;
		double speed = sqrt((Vel.X ** 2) + (Vel.Y ** 2));

		if (buttons & BT_JUMP) {
			buttons &= ~BT_CROUCH;
		}
		if (player.health > 0 && level.IsCrouchingAllowed() && !GetCvar("Sliding") && !GetCvar("IsSpinDashing")) {
			HandleCrouch(player, buttons, totallyfrozen);
		}
		else A_StopSound(12);
	}
}

class LLSwitch : Actor
{
	Default
	{
		+SHOOTABLE
		+NOBLOOD
		+DONTFALL
		+NOGRAVITY
		+NOCLIP
		Health 1;
		Mass 100000;
		YScale 0.9;
		Height 30;
		DamageFactor "Normal", 0;
		DeathSound "switches/normbutn";
	}
	States
	{
		Death:
			ACTS A -1 A_Scream();
			Stop;
	}
}

class LockLoadWeapon : Weapon
{
	override bool DepleteAmmo(bool altFire, bool checkEnough, int ammouse)
	{
		if ((CountInv("PowerSuper", AAPTR_Player1) || CountInv("PowerHyper", AAPTR_Player1))) {
			if (!altfire) {
				A_GiveInventory("ChaosEnergy", AmmoUse1, AAPTR_Player1);
			}
			else {
				A_GiveInventory("ChaosEnergy", AmmoUse2, AAPTR_Player1);
			}
		}
		super.DepleteAmmo(altFire, checkEnough, ammouse);
		return true;
	}
}

class SlamAtkObject : CustomInventory
{
	int inuse;
	int midfall;
	int zdiff;
	
	action void DealSlamDamage(int slam_damage)
	{
		bool ok;
		Actor below;
		[ok, below] = TestMobjZ(true);
		if (below) {
			below.DamageMobj(self, null, slam_damage, "Melee");
			if (below.Pos.Z > below.GetZAt()) below.A_ChangeVelocity(0, 0, -64);
		}
	}

	action void DoSlamBounce()
	{
		Vel.Z = 20 + invoker.zdiff / 41;
		if (invoker.zdiff > 300)
			Vel.Z += 2 * (invoker.zdiff / 300);
		cvar.FindCvar("DidJump").SetBool(true);
	}
	
	action void LaunchEnemies(int range, int thrust)
	{
		for (int set_angle = 0; set_angle <= 360; set_angle++) {
			FTranslatedLineTarget ltinfo;
			bool ltattack = LineAttack(set_angle, range, 0, 0, 'Shockwave', "InvisiblePuff", LAF_NORANDOMPUFFZ, ltinfo, 0);
			let ltarget = ltinfo.linetarget;
			if (ltarget && (ltarget.bIsMonster || ltarget.GetClassName() == "Doox")) {
				int min = 1;
				int max = 20;
				if (thrust < min) thrust = min;
				if (thrust > max) thrust = max;
				ltarget.Vel.Z += thrust;
			}
		}
	}

	action void SlamAttack()
	{
		A_PlaySound("*slam", 1);
		LaunchEnemies(512, invoker.zdiff / 256);
		A_Explode(35, 300, XF_NOTMISSILE, false, 0, 0, 10, "BulletPuff");
		DealSlamDamage(random(1, 8) * 128);
	}

	action void BoundAttack()
	{
		A_PlaySound("*slam", 2);
		DoSlamBounce();
		DealSlamDamage(random(1, 8) * 64);
	}

	override void Tick()
	{
		Super.Tick();
		if (owner.player.onground)
			midfall = false;
	}

	States
	{
		Use:
			TNT1 A 0 A_Overlay(-4, "SlamCheck");
			TNT1 A 0 A_OverlayOffset(-4, 0, 32);
			Fail;
		SlamCheck:
			TNT1 A 0 {
				bool IsHyperAndRClicking = (player.ReadyWeapon.GetClassName() == "Caliburn" || player.ReadyWeapon.GetClassName() == "ClassicAbilities") && GetPlayerInput(MODINPUT_BUTTONS) & BT_ALTATTACK && CountInv("PowerHyper");
				if (!IsHyperAndRClicking && !invoker.midfall) {
					invoker.midfall = true;
					invoker.zdiff = Pos.Z - GetZAt();
					return ResolveState("SlamStart");
				}
				return ResolveState(null);
			}
			Stop;
		SlamStart:
			TNT1 A 0 A_PlaySound("*fall", 1);
			/* passthrough */
		SlamAttack:
			TNT1 A 0 A_Stop();
			TNT1 A 0 A_ChangeVelocity(0, 0, -500, CVF_Replace);
			TNT1 A 1
			{
				if (CountInv("PowerSuper")||CountInv("PowerHyper")) {
					A_CustomPunch(70, CPF_PULLIN, 0, "InvisiblePuff", 75, 0, 0, "ArmorBonus", "sweapons/finalhit");
				}
				else {
					A_CustomPunch(45, CPF_PULLIN, 0, "InvisiblePuff", 75, 0, 0, "ArmorBonus", "sweapons/finalhit");
				}
				if (player.onground) return ResolveState("SlamDone");
				A_ChangeVelocity(0, 0, -75, CVF_Relative|CVF_Replace);
				return ResolveState(null);
			}
			Goto SlamAttack+1;
		SlamDone:
			TNT1 A 0 {
				invoker.midfall = false;
				if (CountInv("ClassicCheck")) {
					return ResolveState("BoundDone");
				}
				A_SetSpeed(0);
				SlamAttack();
				return ResolveState(null);
			}
			TNT1 AAAAA 1 {
				if (GetPlayerInput(MODINPUT_BUTTONS) & BT_JUMP && !(GetPlayerInput(MODINPUT_OLDBUTTONS) & BT_JUMP)) {
					DoSlamBounce();
					return ResolveState(null);
				}
				return ResolveState(null);
			}
			TNT1 A 0 A_SetSpeed(2);
			Stop;
		BoundDone:
			TNT1 A 1 A_Stop();
			TNT1 A 1 BoundAttack();
			TNT1 A 3;
			Stop;
	}
	override void DoEffect()
	{
		Super.DoEffect();
		if (inuse > 0) {
			inuse--;
		}
		bool above_ground = !owner.player.onground;
		bool crouch_pressed = owner.GetPlayerInput(INPUT_BUTTONS) & BT_CROUCH && !(owner.GetPlayerInput(INPUT_OLDBUTTONS) & BT_CROUCH);
		if (owner is "PlayerPawn" && above_ground && crouch_pressed && inuse == 0) {
			owner.UseInventory(self);
			inuse = 6;
		}
	}
}
